[{"id":"0c856332e72bd76c","type":"tab","label":"MQTT Transmission","disabled":false,"info":"","env":[]},{"id":"2881e98bcf59ccb3","type":"junction","z":"0c856332e72bd76c","x":1560,"y":340,"wires":[["d881fe0e1fcd6d3b"]]},{"id":"d881fe0e1fcd6d3b","type":"mqtt out","z":"0c856332e72bd76c","name":"Out to mqtt","topic":"","qos":"1","retain":"false","respTopic":"res/matest","contentType":"","userProps":"","correl":"","expiry":"","broker":"","x":2510,"y":340,"wires":[],"info":"This node takes the message and \npublishes it to your MQTT broker. \nIt's set to QoS 1, which means it \nrequires an acknowledgment (an \"ack\") \nfrom the broker to confirm the \nmessage was received."},{"id":"a332d6e413cb69a0","type":"complete","z":"0c856332e72bd76c","name":"MQTT event listener. ","scope":["d881fe0e1fcd6d3b"],"uncaught":false,"x":1090,"y":380,"wires":[["c2be7254cec5924b","f51c79dcce10da10"]],"info":"This special node is linked to the \nMQTT out node. It only activates \nwhen the MQTT node successfully \nsends the message and gets the \nacknowledgment.\n\nOnce the Complete node is activated, \nit forwards the original \nmessage—which was successfully \ntransmitted via MQTT—to the \nPrepare Data function. "},{"id":"c2be7254cec5924b","type":"debug","z":"0c856332e72bd76c","name":"complete","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":1300,"y":380,"wires":[]},{"id":"311db2cdaff756d3","type":"delay","z":"0c856332e72bd76c","name":"","pauseType":"delayv","timeout":"1","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"allowrate":false,"outputs":1,"x":1600,"y":500,"wires":[["b139803497a98e5a"]]},{"id":"f51c79dcce10da10","type":"function","z":"0c856332e72bd76c","name":"Prepare Data","func":"/*\n\nThis is a key node. When a new message\narrives, this function adds the \nmessage's unique ID (msg._msgid) \nto the messages_pending array. \nThink of this as raising a flag \nthat says, \"I'm trying to send this \nmessage now!\" It then passes the \nmessage on.\n\nIn Node-RED, msg._msgid is a unique \nidentifier automatically assigned \nto each message as it enters a flow. \nThis property is crucial for message \ntracing and debugging within Node-RED.\n\n======================================\n\n(Section 1) When the Complete node activates, it \nsends the original message back to the \nPrepare Data function. This time, the \nfunction sees the message's ID is already \nin the messages_pending list. It interprets \nthis as a success signal, removes the ID \nfrom the list, and stops the message. \nThe process is complete\n\n(Section 2) When a new live or local \nmessage arrive and it does not exist on \nthe messahes_pending, then the function adds the \nID to the messages_pending array.\n\n*/\n\nlet delay = flow.get('mqtt_timeout_ms');\nif(delay != null){\n    msg.delay = delay;\n}\nlet pending = flow.get('messages_pending');\nif(pending != null){\n    /* Section 1 */\n    if (pending.includes(msg._msgid)){\n        pending = pending.filter(id => id !== msg._msgid);\n        flow.set('messages_pending', pending);\n        return;\n    }else{\n    /* Section 2 */\n        pending.push(msg._msgid);\n        flow.set('messages_pending', pending);\n        return msg;\n    }\n}\nreturn msg;","outputs":1,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1390,"y":500,"wires":[["311db2cdaff756d3","2881e98bcf59ccb3"]],"info":"This is a key node. When a new message\narrives, this function adds the \nmessage's unique ID (msg._msgid) \nto the messages_pending array. \nThink of this as raising a flag \nthat says, \"I'm trying to send this \nmessage now!\" It then passes the \nmessage on.\n\nIn Node-RED, msg._msgid is a unique \nidentifier automatically assigned \nto each message as it enters a flow. \nThis property is crucial for message \ntracing and debugging within Node-RED.\n"},{"id":"b139803497a98e5a","type":"function","z":"0c856332e72bd76c","name":"If Message is still pending send to backlog","func":"/*\n\nAfter one second delay, It checks the \nmessages_pending list.\n\nIf the message ID is GONE: It means the \"Happy Path\" \nworked—the Complete node fired and removed the ID. \nThe function does nothing.\n\nIf the message ID is STILL THERE: This is the \nfailure case! It means 1 second has passed and \nthe MQTT out node never reported a success. \nThe message is considered lost. The function then \nsends the failed message to the File node.\n\n*/\n\nlet beFrom = msg.beFrom || false;\nlet filename = flow.get(\"log\");\nlet pending = flow.get('messages_pending');\n\n/* If message is already still in pending list\nand is a live sensor data message */\n\nif(pending.includes(msg._msgid)){\n    if (!beFrom) {\n        pending = pending.filter(id => id !== msg._msgid);\n        flow.set('messages_pending', pending);\n        msg.filename = filename;\n        return [msg, null];\n    }\n}\n/* If is a local backlog message and was sucessfuly\ntransmitted by mqtt */\nelse{\n    if (beFrom == \"local\"){\n        msg.payload = \"sed '1d' \" + filename + \" -i\";\n        return [null, msg];\n    }\n}","outputs":2,"timeout":"","noerr":0,"initialize":"","finalize":"","libs":[],"x":1860,"y":500,"wires":[["a50a5106bb42dfb9"],["076ea7795c0930d4"]],"outputLabels":["to Local","delete Line"]},{"id":"178fb83845881762","type":"inject","z":"0c856332e72bd76c","name":"Set MQTT Timeout + Init pending","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"1000","payloadType":"num","x":860,"y":220,"wires":[["92c1099173b97cd5"]],"info":"This node automatically runs once\nat the very beginning. \nIt sends a message containing \nthe number 1000."},{"id":"92c1099173b97cd5","type":"change","z":"0c856332e72bd76c","name":"set","rules":[{"t":"set","p":"mqtt_timeout_ms","pt":"flow","to":"payload","tot":"msg"},{"t":"set","p":"messages_pending","pt":"flow","to":"[]","tot":"json"}],"action":"","property":"","from":"","to":"","reg":false,"x":1070,"y":220,"wires":[[]],"info":"This node receives the 1000 and does \ntwo things:\n\n1. It creates a flow-wide variable \nnamed mqtt_timeout_ms and sets its \nvalue to 1000. This will be used \nas a 1-second timeout.\n\n2. It creates another flow-wide \nvariable named messages_pending\nand sets it to an empty array [].\nThis array will be used to keep \ntrack of messages that are currently\nbeing sent."},{"id":"a50a5106bb42dfb9","type":"file","z":"0c856332e72bd76c","name":"Store data","filename":"filename","filenameType":"msg","appendNewline":true,"createDir":true,"overwriteFile":"false","encoding":"none","x":2130,"y":460,"wires":[["ae55f0f69909cfed"]],"info":"This node takes the failed message \nand appends it as a new line to \nthe backlog text file:\n\n/home/ncdio/.node-red/backlog/backlog.log \n\nThe message is now safely stored for \na later attempt."},{"id":"3dda4b5d0ef644bf","type":"function","z":"0c856332e72bd76c","name":"get path","func":"/**\n * \n *  This gets the path and creates a command to read \n *  the very first line of the backlog \n *  file (e.g., head -1 /path/to/backlog.log).\n * \n */\n\nlet path = flow.get(\"log\");\nmsg.payload = \"head -1 \" + path;\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":700,"y":880,"wires":[["fdd342f08cff0401"]]},{"id":"fdd342f08cff0401","type":"exec","z":"0c856332e72bd76c","command":"","addpay":"payload","append":"","useSpawn":"false","timer":"","winHide":false,"oldrc":false,"name":"Read first line from backlogs","x":900,"y":880,"wires":[["4a04b8da2d631a62"],["1f61748011e4601c"],["1f61748011e4601c"]],"info":"This node executes the command and \ngets the oldest failed message \nfrom the file."},{"id":"4a04b8da2d631a62","type":"switch","z":"0c856332e72bd76c","name":"If backlogged packet","property":"payload","propertyType":"msg","rules":[{"t":"neq","v":"","vt":"str"}],"checkall":"true","repair":false,"outputs":1,"x":1040,"y":780,"wires":[["d04fd70ade6eb740"]],"info":"This checks if a line was actually \nread. If the file is empty, \nthe flow stops here until the \nnext 10-second trigger."},{"id":"d04fd70ade6eb740","type":"json","z":"0c856332e72bd76c","name":"Extract Failed line","property":"payload","action":"","pretty":true,"x":1090,"y":700,"wires":[["6c6465e9dc6b1e7e"]],"info":"The line read from the file is just \ntext. This node converts that text \nback into a proper message \nobject."},{"id":"6c6465e9dc6b1e7e","type":"change","z":"0c856332e72bd76c","name":"Tag data from Local","rules":[{"t":"set","p":"beFrom","pt":"msg","to":"local","tot":"str"}],"action":"","property":"","from":"","to":"","reg":false,"x":1130,"y":620,"wires":[["f51c79dcce10da10"]],"info":"This node adds a special property \nto the message: beFrom = \"local\". \n\nThis flag is crucial to let the \nflow know this is a local message, \nnot a live one."},{"id":"a2e77c95cc7cc419","type":"debug","z":"0c856332e72bd76c","name":"debug 139","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"true","targetType":"full","statusVal":"","statusType":"auto","x":2430,"y":520,"wires":[]},{"id":"076ea7795c0930d4","type":"exec","z":"0c856332e72bd76c","command":"","addpay":"payload","append":"","useSpawn":"false","timer":"","winHide":false,"oldrc":false,"name":"Remove first line from backlogs","x":2190,"y":540,"wires":[["a2e77c95cc7cc419"],["84698ff85801fd55"],["84698ff85801fd55"]],"info":"This node runs the deletion command, \ncleaning the successfully sent \nmessage from the backlog file. \n\nThe flow is now ready to process \nthe next line in the file on its \nnext run."},{"id":"84698ff85801fd55","type":"debug","z":"0c856332e72bd76c","name":"debug 140","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":2430,"y":560,"wires":[]},{"id":"d6c77e64b8d09c0b","type":"inject","z":"0c856332e72bd76c","name":"Set LogFile","props":[{"p":"payload"}],"repeat":"","crontab":"","once":true,"onceDelay":0.1,"topic":"","payload":"/home/ncdio/.node-red/backlog/backlog.log","payloadType":"str","x":790,"y":260,"wires":[["35835ef953a55d20"]],"info":"This also runs automatically once at \nthe start or after each Deploy.\nIt injects a message containing the \nfile path: \n/home/ncdio/.node-red/backlog/backlog.log."},{"id":"35835ef953a55d20","type":"change","z":"0c856332e72bd76c","name":"set","rules":[{"t":"set","p":"log","pt":"flow","to":"payload","tot":"msg"}],"action":"","property":"","from":"","to":"","reg":false,"x":1070,"y":260,"wires":[[]],"info":"This node takes that file path and \nsaves it in a flow-wide variable \nnamed log. This tells the flow where \nto save failed messages."},{"id":"ae55f0f69909cfed","type":"function","z":"0c856332e72bd76c","name":"clear buff mqtt","func":"/**\n * \n * After saving the file, this function \n * attempts to reset the MQTT connection \n * by quickly disconnecting and reconnecting. \n * \n * This can help clear any potential network issues.\n * \n * first send disconnect, 100 miliseconds after\n * sends connect using node.send() asyncronous \n * function\n * \n */\n\nlet delay = 100;\nmsg = {};\nsetTimeout(() => {\n    msg.action = \"connect\";\n    msg.force;\n    node.send(msg);\n}, delay);\nmsg.force;\nmsg.action = \"disconnect\";\nreturn msg;","outputs":1,"timeout":0,"noerr":0,"initialize":"","finalize":"","libs":[],"x":2300,"y":460,"wires":[["d881fe0e1fcd6d3b"]]},{"id":"db9c2af2ef03c872","type":"inject","z":"0c856332e72bd76c","name":"","props":[],"repeat":"10","crontab":"","once":true,"onceDelay":0.1,"topic":"","x":605,"y":880,"wires":[["3dda4b5d0ef644bf"]],"l":false,"info":"This node kicks off the recovery \nprocess automatically every \n10 seconds."},{"id":"1f61748011e4601c","type":"debug","z":"0c856332e72bd76c","name":"debug 145","active":false,"tosidebar":true,"console":false,"tostatus":false,"complete":"payload","targetType":"msg","statusVal":"","statusType":"auto","x":1110,"y":880,"wires":[]},{"id":"f106c62b8b407a12","type":"switch","z":"0c856332e72bd76c","name":"ncd-filter-sensor-data","property":"topic","propertyType":"msg","rules":[{"t":"eq","v":"sensor_data","vt":"str"}],"checkall":"true","repair":false,"outputs":1,"x":840,"y":500,"wires":[["f51c79dcce10da10"]],"info":"This is the entry point for new data. \nIt acts as a gatekeeper, only \nallowing messages with the topic \nsensor_data to pass through."},{"id":"e491a234e343653d","type":"comment","z":"0c856332e72bd76c","name":"Flow Explanation","info":"This Node-RED flow is a clever system \ndesigned to reliably send data over \nMQTT, even if the network connection\nis unstable.\n\nIts main purpose is to implement a \nstore-and-forward mechanism. \nIf an MQTT message fails to send, \nthe flow saves it to a local file \n(a \"backlog\"). It then periodically \ntries to resend saved messages from \nthis file until it succeeds.","x":780,"y":160,"wires":[]},{"id":"9390e355aabe7094","type":"comment","z":"0c856332e72bd76c","name":"","info":"The message is sent to two places at \nonce from the Prepare Data node: \n\n- One path goes to the MQTT node.\n- The other goes to a Delay node.\n\nDelay Node: This node holds onto a \ncopy of the message for a set \namount of time (in this case, \n1 second, based on the \nmqtt_timeout_ms variable).","x":1600,"y":420,"wires":[]},{"id":"02066608d15d2ec1","type":"ncd-gateway-node","z":"0c856332e72bd76c","name":"","connection":"","unknown_devices":0,"outputs":1,"x":190,"y":500,"wires":[["f106c62b8b407a12"]]},{"id":"149ebdf7e81c2b66","type":"global-config","env":[],"modules":{"@ncd-io/node-red-enterprise-sensors":"1.5.5"}}]
